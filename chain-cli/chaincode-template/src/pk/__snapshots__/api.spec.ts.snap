// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`PublicKeyContract API should match snapshot 1`] = `
{
  "contractName": "PublicKeyContract",
  "contractVersion": "?.?.?",
  "methods": [
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": undefined,
      "isWrite": false,
      "methodName": "GetChaincodeVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": undefined,
      "isWrite": false,
      "methodName": "GetContractAPI",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": "Returns profile for the calling user. Since the profile contains also eth address of the user, this method is supported only for signature based authentication.",
      "dtoSchema": {
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetMyProfile",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectByKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectHistory",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": "[Deprecated] Returns public key for the user",
      "dtoSchema": {
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "user": {
            "description": "Id of a public key holder. Optional field, by default caller's public key is returned.",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetPublicKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "publicKey": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "publicKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": "Registers a new user on chain under alias derived from eth address.",
      "dtoSchema": {
        "description": "Dto for secure method to save public keys for Eth users. Method is called and signed by Curators",
        "properties": {
          "publicKey": {
            "description": "A public key to be saved on chain.
It should be just the private part of the EC secp256k1 key, than can be retrieved this way: \`openssl ec -in priv-key.pem -text | grep pub -A 5 | tail -n +2 | tr -d '\\n[:space:]:\`. The previous command produces an uncompressed hex string, but you can also provide an compressed one, as well as compressed and uncompressed base64 secp256k1 key. A secp256k1 public key is saved on chain as compressed base64 string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "publicKey",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RegisterEthUser",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": "Registers a new user on chain under provided user alias.",
      "dtoSchema": {
        "description": "Dto for secure method to save public keys for legacy users. Method is called and signed by Curators",
        "properties": {
          "publicKey": {
            "description": "A public key to be saved on chain.
It should be just the private part of the EC secp256k1 key, than can be retrieved this way: \`openssl ec -in priv-key.pem -text | grep pub -A 5 | tail -n +2 | tr -d '\\n[:space:]:\`. The previous command produces an uncompressed hex string, but you can also provide an compressed one, as well as compressed and uncompressed base64 secp256k1 key. A secp256k1 public key is saved on chain as compressed base64 string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "user": {
            "description": "Id of user to save public key for.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "user",
          "publicKey",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RegisterUser",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": "Updates public key for the calling user.",
      "dtoSchema": {
        "properties": {
          "publicKey": {
            "description": "A public key to be saved on chain.
It should be just the private part of the EC secp256k1 key, than can be retrieved this way: \`openssl ec -in priv-key.pem -text | grep pub -A 5 | tail -n +2 | tr -d '\\n[:space:]:\`. The previous command produces an uncompressed hex string, but you can also provide an compressed one, as well as compressed and uncompressed base64 secp256k1 key. A secp256k1 public key is saved on chain as compressed base64 string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "publicKey",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UpdatePublicKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": "Verifies signature of the DTO signed with caller's private key to be verified with user's public key saved on chain.",
      "dtoSchema": {
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "VerifySignature",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
  ],
}
`;
