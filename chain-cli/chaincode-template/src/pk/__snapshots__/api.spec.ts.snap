// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`PublicKeyContract API should match snapshot 1`] = `
{
  "chaincodeId": "chaincode-id",
  "channelId": "channel-id",
  "contractName": "PublicKeyContract",
  "contractVersion": "?.?.?",
  "methods": [
    {
      "description": "Adds a signer to the calling user's multisig setup. Transaction updates the chain (submit). Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signer": {
            "description": "User ref of the signer to add (typically Ethereum address, or user alias).",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "signer",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "AddSigner",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Evaluate a batch of transactions Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "noPartialSuccess": {
            "description": "If true, the batch will fail if any of the operations fail. If false, the batch will continue even if some of the operations fail. Default: false.",
          },
          "operations": {
            "items": {
              "properties": {
                "dto": {
                  "minLength": 1,
                  "properties": {
                    "dtoExpiresAt": {
                      "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
                      "type": "number",
                    },
                    "dtoOperation": {
                      "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
                      "minLength": 1,
                      "type": "string",
                    },
                    "multisig": {
                      "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
                      "items": {},
                      "minItems": 2,
                      "type": "array",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "type": "object",
                },
                "dtoExpiresAt": {
                  "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
                  "type": "number",
                },
                "dtoOperation": {
                  "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
                  "minLength": 1,
                  "type": "string",
                },
                "method": {
                  "minLength": 1,
                  "type": "string",
                },
                "multisig": {
                  "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
                  "items": {},
                  "minItems": 2,
                  "type": "array",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "method",
                "dto",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "writesLimit": {
            "description": "Soft limit of keys written to chain in a batch, excluding deletes. If the limit is exceeded, all subsequent operations in batch fail. Typically it is safe to repeat failed operations in the next batch. Default: 10000. Max: 100000.",
            "maximum": 100000,
            "minimum": 1,
            "type": "number",
          },
        },
        "required": [
          "operations",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "BatchEvaluate",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Submit a batch of transactions Transaction updates the chain (submit). Allowed roles: SUBMIT. Allowed orgs: CuratorOrg.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "noPartialSuccess": {
            "description": "If true, the batch will fail if any of the operations fail. If false, the batch will continue even if some of the operations fail. Default: false.",
          },
          "operations": {
            "items": {
              "properties": {
                "dto": {
                  "minLength": 1,
                  "properties": {
                    "dtoExpiresAt": {
                      "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
                      "type": "number",
                    },
                    "dtoOperation": {
                      "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
                      "minLength": 1,
                      "type": "string",
                    },
                    "multisig": {
                      "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
                      "items": {},
                      "minItems": 2,
                      "type": "array",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "type": "object",
                },
                "dtoExpiresAt": {
                  "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
                  "type": "number",
                },
                "dtoOperation": {
                  "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
                  "minLength": 1,
                  "type": "string",
                },
                "method": {
                  "minLength": 1,
                  "type": "string",
                },
                "multisig": {
                  "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
                  "items": {},
                  "minItems": 2,
                  "type": "array",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "method",
                "dto",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "writesLimit": {
            "description": "Soft limit of keys written to chain in a batch, excluding deletes. If the limit is exceeded, all subsequent operations in batch fail. Typically it is safe to repeat failed operations in the next batch. Default: 10000. Max: 100000.",
            "maximum": 100000,
            "minimum": 1,
            "type": "number",
          },
        },
        "required": [
          "operations",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BatchSubmit",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "callerPublicKey": {
            "minLength": 1,
            "type": "string",
          },
          "dto": {
            "minLength": 1,
            "type": "string",
          },
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "method": {
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "method",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "DryRun",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "dtoExpiresAt": {
                "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
                "type": "number",
              },
              "dtoOperation": {
                "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
                "minLength": 1,
                "type": "string",
              },
              "multisig": {
                "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
                "items": {},
                "minItems": 2,
                "type": "array",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "deprecated": true,
      "description": "Gets the contract version. Deprecated. Use GetContractVersion instead. Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "isWrite": false,
      "methodName": "GetChaincodeVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "isWrite": false,
      "methodName": "GetContractAPI",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "isWrite": false,
      "methodName": "GetContractVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Returns profile for the calling user. Since the profile contains also eth address of the user, this method is supported only for signature based authentication. Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetMyProfile",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectByKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": " Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectHistory",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Returns public key for the user Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "user": {
            "description": "Id of a public key holder. Optional field, by default caller's public key is returned.",
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetPublicKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "publicKey": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "publicKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "deprecated": true,
      "description": "Registration of eth| users is no longer required. This method will be removed in the future. Transaction updates the chain (submit). Allowed roles: REGISTRAR.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RegisterEthUser",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "deprecated": true,
      "description": "Registration of ton| users is no longer required. This method will be removed in the future. Transaction updates the chain (submit). Allowed roles: REGISTRAR.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RegisterTonUser",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Registers a new user on chain under provided user alias. Transaction updates the chain (submit). Allowed roles: REGISTRAR.",
      "dtoSchema": {
        "description": "Dto for secure method to save public keys for legacy users. Method is called and signed by Curators",
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "publicKey": {
            "description": "Public secp256k1 key (compact or non-compact, hex or base64).",
            "minLength": 1,
            "type": "string",
          },
          "publicKeySignature": {
            "description": "Signature from the public key.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signatureQuorum": {
            "description": "Minimum number of signatures required for authorization. Defaults to number of public keys.",
            "minimum": 1,
            "type": "integer",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signers": {
            "description": "Signer user refs.",
            "items": {
              "description": "Allowed value is a user alias ('client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username), or valid Ethereum address.",
              "minLength": 1,
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "user": {
            "description": "Id of user to save public key for.",
            "type": "string",
          },
        },
        "required": [
          "user",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RegisterUser",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Removes a signer from the calling user's multisig setup. Transaction updates the chain (submit). Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signer": {
            "description": "User ref of the signer to remove (typically Ethereum address, or user alias).",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "signer",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RemoveSigner",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Updates public key for the calling user. Transaction updates the chain (submit). Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "publicKey": {
            "description": "New public key for the user. For users with ETH signing scheme it is public secp256k1 key (compact or non-compact, hex or base64). For users with TON signing scheme it is public Ed25519 key (base64).",
            "minLength": 1,
            "type": "string",
          },
          "publicKeySignature": {
            "description": "Signature from the new public key. The signature should be created over the same data as the main signature of this DTO, but the \`signature\` and \`multisig\` fields should be empty. This is to prove that the caller has access to the private key of the new public key.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "publicKey",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UpdatePublicKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Updates the signature quorum for the calling user's multisig setup. Transaction updates the chain (submit). Allowed roles: SUBMIT.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quorum": {
            "description": "New quorum for the user.",
            "minimum": 1,
            "type": "integer",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "quorum",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UpdateQuorum",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Updates roles for the user with alias provided in DTO. Transaction updates the chain (submit). Allowed roles: REGISTRAR.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "roles": {
            "description": "New set of roles for the user that will replace the old ones.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "user": {
            "description": "Allowed value is a user alias ('client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username), or valid Ethereum address.",
            "type": "string",
          },
        },
        "required": [
          "user",
          "roles",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UpdateUserRoles",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "description": "Verifies signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. Transaction is read only (evaluate). Allowed roles: EVALUATE.",
      "dtoSchema": {
        "properties": {
          "dtoExpiresAt": {
            "description": "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid.",
            "type": "number",
          },
          "dtoOperation": {
            "description": "Full operation identifier that is called on chain with this DTO. The format is \`channelId_chaincodeId_methodName\`. It is required for multisig DTOs, and optional for single signed DTOs. ",
            "minLength": 1,
            "type": "string",
          },
          "multisig": {
            "description": "List of signatures for this DTO if there are multiple signers. If there are multiple signatures, 'signerAddress' is required, and it is not allowed to provide 'signature' or 'signerPublicKey' or 'prefix' fields, and the signing scheme must be ETH.",
            "items": {},
            "minItems": 2,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum address, or user alias.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "VerifySignature",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
  ],
}
`;
