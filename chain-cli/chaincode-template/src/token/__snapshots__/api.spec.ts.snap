// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GalaChainTokenContract API should match snapshot 1`] = `
{
  "contractName": "GalaChainToken",
  "contractVersion": "?.?.?",
  "methods": [
    {
      "dtoSchema": {
        "description": "Describes an action to transferToken a token. For NFTs you can mint up to 1000 tokens.",
        "properties": {
          "mintDtos": {
            "description": "DTOs of tokens to mint.",
            "items": {
              "description": "Describes an action to mint a token. For NFTs you can mint up to 1000 tokens.",
              "properties": {
                "allowanceKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "owner": {
                  "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "How many units of Fungible/NonFungible Token will be minted. Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "tokenClass": {
                  "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                  ],
                  "type": "object",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "tokenClass",
                "quantity",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "mintDtos",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BatchMintToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Defines burns to be created.",
        "properties": {
          "owner": {
            "description": "Owner of the tokens to be burned. If not provided, the calling user is assumed to be the owner.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstances": {
            "description": "Array of token instances of token to be burned. In case of fungible tokens, tokenInstance.instance field should be set to 0 and quantity set to 1.",
            "items": {
              "properties": {
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "tokenInstanceKey": {
                  "description": "Object representing the chain identifier of token instance.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
              },
              "required": [
                "tokenInstanceKey",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BurnTokens",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "burnedBy": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "burnedBy",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "created",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains properties of token class to be created. Actual token units and NFT instances are created on mint.",
        "properties": {
          "authorities": {
            "description": "List of chain user identifiers who should become token authorities. Only token authorities can give mint allowances. By default the calling user becomes a single token authority. ",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
          "contractAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "decimals": {
            "description": "If missing, and for NFTs, it is set to 0.",
            "maximum": 32,
            "minimum": 0,
            "type": "number",
          },
          "description": {
            "maxLength": 1000,
            "minLength": 1,
            "type": "string",
          },
          "image": {
            "format": "url",
            "type": "string",
          },
          "isNonFungible": {
            "description": "Determines if the token is an NFT. Set to false if missing.",
            "type": "boolean",
          },
          "maxCapacity": {
            "description": "If missing, set to Infinity. Number provided as a string.",
            "type": "string",
          },
          "maxSupply": {
            "description": "If missing, set to infinity Infinity. Number provided as a string.",
            "type": "string",
          },
          "metadataAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "name": {
            "maxLength": 200,
            "type": "string",
          },
          "network": {
            "description": "A network of the token. An optional field, by default set to GC. Custom value is required when we want to use different network than GC to store tokens (but this is not supported yet).",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "rarity": {
            "description": "How rare is the NFT",
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "symbol": {
            "maxLength": 20,
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "tokenClass": {
            "description": "A unique identifier of this token. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "totalBurned": {
            "description": "How much units or how many NFTs ware already burned. By default set to 0. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "totalMintAllowance": {
            "description": "How much units or how many NFTs were allowed to be minted in the past. By default set to 0. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "totalSupply": {
            "description": "How much units or how many NFTs are already on the market. By default set to 0. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "name",
          "symbol",
          "description",
          "image",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "CreateTokenClass",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Object representing the chain identifier of token class.",
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Fee Verification DTO. With a valid signature from an Authoritative User, used to verify that a Fee was paid across channels. Typically, this will be a type of multi-signature DTO or a double signed DTO. That is, the \`authorization\` property contains the original authorization DTO signed by the End User. And the overall FeeVerificationDto will be signed by an Authoritative/Administrative user (i.e. a CuratorUser). The Chaincode can then verify definitively that both a) the end user did authorize a spend, and b) the Authoritative/Administrative user confirms that this authorization was successfully approved/written/burned on the assets channel.",
        "properties": {
          "authority": {
            "description": "The user authorizing a GalaChainFee payment. Expected to be the same user which signed the DTO provided in the \`authorization\` property.",
            "type": "string",
          },
          "created": {
            "description": "Unix Timestamp of fee authorization chain object creation.",
            "minLength": 1,
            "type": "string",
          },
          "feeAuthorizationKey": {
            "description": "Chain Key referencing Fee Authorization Chain Object saved in World State.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "Token Quantity authorized with this fee. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "txId": {
            "description": "Transaction ID where authorization was granted for fee spend.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "authority",
          "created",
          "txId",
          "quantity",
          "feeAuthorizationKey",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "CreditFeeBalance",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Fee Authorization Response DTO. Data transfer object representing a successful transaction response to a FeeAuthorization.",
            "properties": {
              "authority": {
                "description": "The user that authorized the GalaChainFee payment.",
                "type": "string",
              },
              "created": {
                "description": "Unix Timestamp of fee authorization chain object creation.",
                "minLength": 1,
                "type": "string",
              },
              "feeAuthorizationKey": {
                "description": "Chain Key of the Fee Authorization Chain Object newly saved in World State.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "Token Quantity authorized with this fee. Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "txId": {
                "description": "Transaction ID where authorization was granted for fee spend.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "authority",
              "created",
              "txId",
              "quantity",
              "feeAuthorizationKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Define a Fee Rate Schedule for a Fee Code.",
        "properties": {
          "baseQuantity": {
            "description": "Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "feeAccelerationRate": {
            "description": "Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "feeAccelerationRateType": {
            "description": "Type of FeeAccelerationRate.",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
            ],
            "type": "number",
          },
          "feeCode": {
            "minLength": 1,
            "type": "string",
          },
          "feeThresholdTimePeriod": {
            "type": "number",
          },
          "feeThresholdUses": {
            "description": "Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "isCrossChannel": {
            "description": "(Optional) Set to 'true' to debit fees from cross-channel pending balances. Set 'true' if $GALA is not defined on this channel. Set to 'false' or leave undefined for fees assessed on the assets channel where users maintain their $GALA balances.",
            "type": "boolean",
          },
          "maxQuantity": {
            "description": "Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "feeCode",
          "feeThresholdUses",
          "feeThresholdTimePeriod",
          "baseQuantity",
          "maxQuantity",
          "feeAccelerationRateType",
          "feeAccelerationRate",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "DefineFeeSchedule",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "baseQuantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "feeAccelerationRate": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "feeAccelerationRateType": {
                "description": "0 - CuratorDefined, 1 - Additive, 2 - Multiplicative, 3 - Exponential, 4 - Logarithmic, 5 - Custom",
                "enum": [
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                ],
                "type": "number",
              },
              "feeCode": {
                "minLength": 1,
                "type": "string",
              },
              "feeThresholdTimePeriod": {
                "type": "number",
              },
              "feeThresholdUses": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "isCrossChannel": {
                "type": "boolean",
              },
              "maxQuantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "maxUses": {
                "description": "Number provided as a string.",
                "type": "string",
              },
            },
            "required": [
              "feeCode",
              "feeThresholdUses",
              "feeThresholdTimePeriod",
              "baseQuantity",
              "maxQuantity",
              "feeAccelerationRateType",
              "feeAccelerationRate",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Define a Formula for a Fee Code that splits the Fee between a burn percentage and one or more transfer addresses/identities, e.g. locked pools used for rewards or redemption",
        "properties": {
          "burnPercentage": {
            "description": "A number between 0 and 1 that represents the percentage / proportion of the total fee which should be burned. e.g 0.9 for '90%'. ",
            "maximum": 1,
            "minimum": 0,
            "type": "number",
          },
          "feeCode": {
            "description": "feeCode which this split formula should apply to. If the FeeCodeDefinition object does not exist on chain yet, the chaincode will throw an error. Be sure to define a FeeCodeDefinition before attempting to define a split formula.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "transferPercentages": {
            "description": "FeeCodeTransferPercentage objects represent the identity or identities to which a percentage (or percentages) of the paid fee should be transferred to instead of being burned.",
            "items": {
              "description": "Define an address/identity to which a percentage of Fees should be transferred.",
              "properties": {
                "transferPercentage": {
                  "description": "A number between 0 and 1 that represents the percentage / proportion of the total fee which should be transferred to the accompany user identity / address. e.g 0.1 for '10%'. ",
                  "maximum": 1,
                  "minimum": 0,
                  "type": "number",
                },
                "transferToUser": {
                  "description": "User identity / GalaChain address representing the address to which this portion of the fee should be transferred.",
                  "type": "string",
                },
              },
              "required": [
                "transferToUser",
                "transferPercentage",
              ],
              "type": "object",
            },
            "minItems": 0,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "feeCode",
          "burnPercentage",
          "transferPercentages",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "DefineFeeSplitFormula",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "burnPercentage": {
                "maximum": 1,
                "minimum": 0,
                "type": "number",
              },
              "feeCode": {
                "minLength": 1,
                "type": "string",
              },
              "transferPercentages": {
                "items": {
                  "description": "Define an address/identity to which a percentage of Fees should be transferred.",
                  "properties": {
                    "transferPercentage": {
                      "description": "A number between 0 and 1 that represents the percentage / proportion of the total fee which should be transferred to the accompany user identity / address. e.g 0.1 for '10%'. ",
                      "maximum": 1,
                      "minimum": 0,
                      "type": "number",
                    },
                    "transferToUser": {
                      "description": "User identity / GalaChain address representing the address to which this portion of the fee should be transferred.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "transferToUser",
                    "transferPercentage",
                  ],
                  "type": "object",
                },
                "minItems": 0,
                "type": "array",
              },
            },
            "required": [
              "feeCode",
              "burnPercentage",
              "transferPercentages",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains parameters for deleting allowances for a calling user.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "allowanceType": {
            "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
            ],
            "type": "number",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "grantedBy": {
            "description": "User who granted allowances.",
            "type": "string",
          },
          "grantedTo": {
            "description": "A user who can use an allowance.",
            "type": "string",
          },
          "instance": {
            "description": "Token instance. Optional, but required if allowanceType is provided",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "grantedTo",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "DeleteAllowances",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "number",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "properties": {
          "callerPublicKey": {
            "minLength": 1,
            "type": "string",
          },
          "dto": {
            "minLength": 1,
            "type": "string",
          },
          "method": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "method",
          "callerPublicKey",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "DryRun",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains parameters for fetching allowances with pagination.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "allowanceType": {
            "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
            ],
            "type": "number",
          },
          "bookmark": {
            "description": "Page bookmark. If it is undefined, then the first page is returned.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "grantedBy": {
            "description": "User who granted allowances.",
            "type": "string",
          },
          "grantedTo": {
            "description": "A user who can use an allowance.",
            "type": "string",
          },
          "instance": {
            "description": "Token instance. Optional, but required if allowanceType is provided",
            "minLength": 1,
            "type": "string",
          },
          "limit": {
            "description": "Page size limit. Defaults to 1000, max possible value 10000. Note you will likely get less results than the limit, because the limit is applied before additional filtering.",
            "maximum": 10000,
            "minimum": 1,
            "type": "number",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "grantedTo",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchAllowances",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "nextPageBookmark": {
                "description": "Next page bookmark.",
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "results": {
                "description": "List of allowances.",
                "items": {
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "allowanceType": {
                      "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
                      "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                      ],
                      "type": "number",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "grantedBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "grantedTo": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "quantitySpent": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uses": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "usesSpent": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "grantedTo",
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                    "allowanceType",
                    "grantedBy",
                    "created",
                    "uses",
                    "expires",
                    "quantity",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "results",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains parameters for fetching balances. Each parameter is optional.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey.",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "Person who owns the balance. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchBalances",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains parameters for fetching balances. Each parameter is optional.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey.",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "Person who owns the balance. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchBalancesWithTokenMetadata",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains parameters for fetching burns.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "burnedBy": {
            "description": "The user who burned the token.",
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "created": {
            "description": "Created time. Optional.",
            "exclusiveMinimum": 0,
            "type": "number",
          },
          "instance": {
            "description": "Token instance. Optional, but required if allowanceType is provided.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "burnedBy",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchBurns",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "burnedBy": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "burnedBy",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "created",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Query channel for Transaction FeeSchedule, comprised of currently-defined FeeCodes.",
        "properties": {
          "feeCode": {
            "description": "Limit query to a specific fee code.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchFeeSchedule",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Response DTO from a successful FetchFeeSchedule request.",
            "properties": {
              "nextPageBookmark": {
                "description": "Next page bookmark",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "results": {
                "description": "List of fee code definitions.",
                "items": {
                  "properties": {
                    "baseQuantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "feeAccelerationRate": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "feeAccelerationRateType": {
                      "description": "0 - CuratorDefined, 1 - Additive, 2 - Multiplicative, 3 - Exponential, 4 - Logarithmic, 5 - Custom",
                      "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                      ],
                      "type": "number",
                    },
                    "feeCode": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "feeThresholdTimePeriod": {
                      "type": "number",
                    },
                    "feeThresholdUses": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "isCrossChannel": {
                      "type": "boolean",
                    },
                    "maxQuantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "maxUses": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "feeCode",
                    "feeThresholdUses",
                    "feeThresholdTimePeriod",
                    "baseQuantity",
                    "maxQuantity",
                    "feeAccelerationRateType",
                    "feeAccelerationRate",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "results",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Fetch Fee Threshold Uses for a Fee Code and User.",
        "properties": {
          "feeCode": {
            "description": "feeCode identifier for which this fee was paid.",
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "user": {
            "description": "user who paid this fee.",
            "type": "string",
          },
        },
        "required": [
          "feeCode",
          "user",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchFeeThresholdUses",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "cumulativeFeeQuantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "cumulativeUses": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "feeCode": {
                "minLength": 1,
                "type": "string",
              },
              "user": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "type": "string",
              },
            },
            "required": [
              "feeCode",
              "user",
              "cumulativeUses",
              "cumulativeFeeQuantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Fetch Fee Threshold Uses with pagination. Optionally limit by feeCode.",
        "properties": {
          "bookmark": {
            "description": "Next page bookmark.",
            "minLength": 1,
            "type": "string",
          },
          "feeCode": {
            "description": "feeCode identifier to limit search results.",
            "minLength": 1,
            "type": "string",
          },
          "limit": {
            "description": "Limit number of results. Useful for pagination queries.",
            "type": "number",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchFeeThresholdUsesWithPagination",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Response DTO from a Fetch Fee Threshold Uses with pagination request.",
            "properties": {
              "nextPageBookmark": {
                "description": "Next page bookmark.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "results": {
                "description": "List of FeeThresholdUses.",
                "items": {
                  "description": "Chain Object Value with Chain Key.",
                  "properties": {
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "value": {
                      "description": "Chain key identifying object on chain.",
                      "type": "object",
                    },
                  },
                  "required": [
                    "value",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "results",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Fetch MintRequest or MintAllowanceRequest objects off chain.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection.",
            "minLength": 1,
            "type": "string",
          },
          "endTimestamp": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "startTimestamp": {
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "collection",
          "category",
          "type",
          "additionalKey",
          "startTimestamp",
          "endTimestamp",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchMintRequests",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Minimal property set represnting a mint request.",
              "properties": {
                "additionalKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "allowanceKey": {
                  "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                  "minLength": 1,
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "id": {
                  "minLength": 1,
                  "type": "string",
                },
                "owner": {
                  "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                  "type": "string",
                },
                "timeKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "totalKnownMintsCount": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "timeKey",
                "totalKnownMintsCount",
                "id",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Contains list of objects representing token classes to fetch.",
        "properties": {
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenClasses": {
            "items": {
              "description": "Object representing the chain identifier of token class.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClasses",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchTokenClasses",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "authorities": {
                  "items": {
                    "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                    "type": "string",
                  },
                  "type": "array",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "contractAddress": {
                  "maxLength": 500,
                  "type": "string",
                },
                "decimals": {
                  "maximum": 32,
                  "minimum": 0,
                  "type": "number",
                },
                "description": {
                  "maxLength": 1000,
                  "minLength": 1,
                  "type": "string",
                },
                "image": {
                  "maxLength": 500,
                  "minLength": 1,
                  "type": "string",
                },
                "isNonFungible": {
                  "type": "boolean",
                },
                "knownMintAllowanceSupply": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "knownMintSupply": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "maxCapacity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "maxSupply": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "metadataAddress": {
                  "maxLength": 500,
                  "type": "string",
                },
                "name": {
                  "minLength": 1,
                  "type": "string",
                },
                "network": {
                  "enum": [
                    "GC",
                  ],
                  "minLength": 1,
                  "type": "string",
                },
                "rarity": {
                  "pattern": "^[a-zA-Z]+$",
                  "type": "string",
                },
                "symbol": {
                  "minLength": 1,
                  "pattern": "^[a-zA-Z]+$",
                  "type": "string",
                },
                "totalBurned": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "totalMintAllowance": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "totalSupply": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "network",
                "decimals",
                "maxSupply",
                "isNonFungible",
                "maxCapacity",
                "authorities",
                "name",
                "symbol",
                "description",
                "image",
                "totalBurned",
                "totalMintAllowance",
                "totalSupply",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Fetch token classes currently available in world state. Supports filtering, pagination, and optionality of TokenClassKey properties.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "bookmark": {
            "description": "Page bookmark. If it is undefined, then the first page is returned.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "limit": {
            "description": "Page size limit. Defaults to 1000, max possible value 10000. Note you will likely get less results than the limit, because the limit is applied before additional filtering.",
            "maximum": 10000,
            "minimum": 1,
            "type": "number",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchTokenClassesWithPagination",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "nextPageBookmark": {
                "description": "Next page bookmark.",
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "results": {
                "description": "List of Token Classes.",
                "items": {
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "authorities": {
                      "items": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "type": "array",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "contractAddress": {
                      "maxLength": 500,
                      "type": "string",
                    },
                    "decimals": {
                      "maximum": 32,
                      "minimum": 0,
                      "type": "number",
                    },
                    "description": {
                      "maxLength": 1000,
                      "minLength": 1,
                      "type": "string",
                    },
                    "image": {
                      "maxLength": 500,
                      "minLength": 1,
                      "type": "string",
                    },
                    "isNonFungible": {
                      "type": "boolean",
                    },
                    "knownMintAllowanceSupply": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "knownMintSupply": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "maxCapacity": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "maxSupply": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "metadataAddress": {
                      "maxLength": 500,
                      "type": "string",
                    },
                    "name": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "network": {
                      "enum": [
                        "GC",
                      ],
                      "minLength": 1,
                      "type": "string",
                    },
                    "rarity": {
                      "pattern": "^[a-zA-Z]+$",
                      "type": "string",
                    },
                    "symbol": {
                      "minLength": 1,
                      "pattern": "^[a-zA-Z]+$",
                      "type": "string",
                    },
                    "totalBurned": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "totalMintAllowance": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "totalSupply": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "network",
                    "decimals",
                    "maxSupply",
                    "isNonFungible",
                    "maxCapacity",
                    "authorities",
                    "name",
                    "symbol",
                    "description",
                    "image",
                    "totalBurned",
                    "totalMintAllowance",
                    "totalSupply",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "results",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
        "properties": {
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "requests": {
            "$ref": "#/definitions/Array",
            "items": {
              "description": "Minimal property set represnting a mint request.",
              "properties": {
                "additionalKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "allowanceKey": {
                  "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                  "minLength": 1,
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "id": {
                  "minLength": 1,
                  "type": "string",
                },
                "owner": {
                  "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                  "type": "string",
                },
                "timeKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "totalKnownMintsCount": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "timeKey",
                "totalKnownMintsCount",
                "id",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "requests",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "FulfillMint",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Fetch one or more balances, verify all owned TokenInstances have at least one available allowance of the specified type. Any token instance key(s) with no available allowances will be returned in the response.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, and ignored if type is not provided.",
          },
          "allowanceType": {
            "description": "AllowanceType to check. Default: Use (0)",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, and ignored if collection is not provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional.",
            "minLength": 1,
            "type": "string",
          },
          "grantedTo": {
            "description": "Person/UserId to whom allowance(s) were granted. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "owner": {
            "description": "Person who owns the balance(s). If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, and ignored if category is not provded.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FullAllowanceCheck",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Response Data Transfer Object for FullLockAllowance request.",
            "properties": {
              "all": {
                "description": "True if all resulting token(s) have active/un-expired allowances available.",
                "type": "boolean",
              },
              "missing": {
                "description": "TokenInstanceKey(s) of any tokens missing the requested AllowanceType.",
                "items": {
                  "description": "Object representing the chain identifier of token instance.",
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
                "minItems": 1,
                "type": "array",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "all",
              "missing",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "deprecated": true,
      "description": "Gets the contract version. Deprecated. Use GetContractVersion instead.",
      "isWrite": false,
      "methodName": "GetChaincodeVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "isWrite": false,
      "methodName": "GetContractAPI",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "isWrite": false,
      "methodName": "GetContractVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectByKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectHistory",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Defines allowances to be created.",
        "properties": {
          "allowanceType": {
            "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
            ],
            "minLength": 1,
            "type": "string",
          },
          "expires": {
            "description": "Unix timestamp of the date when the allowances should expire. 0 means that it won' expire. By default set to 0.",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantities": {
            "$ref": "#/definitions/Array",
            "description": "List of objects with user and token quantities. The user fields must be unique",
            "items": {
              "properties": {
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "user": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "user",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token which the allowance concerns. In case of fungible tokens, tokenInstance.instance field should be set to 0. A full or partial key of a TokenInstance, for querying or actioning one or more instances of a token.",
            "minLength": 1,
            "properties": {
              "additionalKey": {},
              "category": {},
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {},
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "uses": {
            "description": "How many times each allowance can be used. Number provided as a string.",
            "type": "string",
          },
        },
        "required": [
          "tokenInstance",
          "quantities",
          "allowanceType",
          "uses",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "GrantAllowance",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "allowanceType": {
                  "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
                  "enum": [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                  ],
                  "type": "number",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "expires": {
                  "minimum": 0,
                  "type": "number",
                },
                "grantedBy": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "grantedTo": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantitySpent": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uses": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "usesSpent": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
              },
              "required": [
                "grantedTo",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "allowanceType",
                "grantedBy",
                "created",
                "uses",
                "expires",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Experimental: Describes an action to mint a token. High-throughput implementation. DTO properties backwards-compatible with prior MintTokenDto,",
        "properties": {
          "allowanceKey": {
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of fungible token of how many NFTs are going to be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "HighThroughputMint",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": [
        {
          "dtoSchema": {
            "description": "Experimental: Describes an action to mint a token. High-throughput implementation. DTO properties backwards-compatible with prior MintTokenDto,",
            "properties": {
              "allowanceKey": {
                "minLength": 1,
                "type": "string",
              },
              "owner": {
                "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "How many units of fungible token of how many NFTs are going to be minted. Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "tokenClass": {
                "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
                "minLength": 1,
                "properties": {
                  "additionalKey": {
                    "not": {
                      "type": "null",
                    },
                  },
                  "category": {
                    "minLength": 1,
                    "type": "string",
                  },
                  "collection": {
                    "minLength": 1,
                    "type": "string",
                  },
                  "prefix": {
                    "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signature": {
                    "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerAddress": {
                    "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerPublicKey": {
                    "description": "Public key of the user who signed the DTO.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signing": {
                    "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                    "enum": [
                      "ETH",
                      "TON",
                    ],
                    "type": "string",
                  },
                  "type": {
                    "minLength": 1,
                    "type": "string",
                  },
                  "uniqueKey": {
                    "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                    "minLength": 1,
                    "type": "string",
                  },
                },
                "required": [
                  "collection",
                  "category",
                  "type",
                  "additionalKey",
                ],
                "type": "object",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "tokenClass",
              "quantity",
            ],
            "type": "object",
          },
          "isWrite": true,
          "methodName": "RequestMint",
          "responseSchema": {
            "properties": {
              "Data": {
                "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
                "properties": {
                  "prefix": {
                    "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "requests": {
                    "$ref": "#/definitions/Array",
                    "items": {
                      "description": "Minimal property set represnting a mint request.",
                      "properties": {
                        "additionalKey": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "allowanceKey": {
                          "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                          "minLength": 1,
                          "type": "string",
                        },
                        "category": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "collection": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "id": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "owner": {
                          "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                          "type": "string",
                        },
                        "timeKey": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "totalKnownMintsCount": {
                          "description": "Number provided as a string.",
                          "type": "string",
                        },
                        "type": {
                          "minLength": 1,
                          "type": "string",
                        },
                      },
                      "required": [
                        "collection",
                        "category",
                        "type",
                        "additionalKey",
                        "timeKey",
                        "totalKnownMintsCount",
                        "id",
                      ],
                      "type": "object",
                    },
                    "maxItems": 1000,
                    "minItems": 1,
                    "type": "array",
                  },
                  "signature": {
                    "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerAddress": {
                    "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerPublicKey": {
                    "description": "Public key of the user who signed the DTO.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signing": {
                    "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                    "enum": [
                      "ETH",
                      "TON",
                    ],
                    "type": "string",
                  },
                  "uniqueKey": {
                    "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                    "minLength": 1,
                    "type": "string",
                  },
                },
                "required": [
                  "requests",
                ],
                "type": "object",
              },
              "Message": {
                "type": "string",
              },
              "Status": {
                "description": "Indicates Error (0) or Success (1)",
                "enum": [
                  0,
                  1,
                ],
              },
            },
            "required": [
              "Status",
            ],
            "type": "object",
          },
        },
        {
          "dtoSchema": {
            "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
            "properties": {
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "requests": {
                "$ref": "#/definitions/Array",
                "items": {
                  "description": "Minimal property set represnting a mint request.",
                  "properties": {
                    "additionalKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "allowanceKey": {
                      "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "id": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "owner": {
                      "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                      "type": "string",
                    },
                    "timeKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "totalKnownMintsCount": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "timeKey",
                    "totalKnownMintsCount",
                    "id",
                  ],
                  "type": "object",
                },
                "maxItems": 1000,
                "minItems": 1,
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "requests",
            ],
            "type": "object",
          },
          "isWrite": true,
          "methodName": "FulfillMint",
          "responseSchema": {
            "properties": {
              "Data": {
                "items": {
                  "description": "Object representing the chain identifier of token instance.",
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "Message": {
                "type": "string",
              },
              "Status": {
                "description": "Indicates Error (0) or Success (1)",
                "enum": [
                  0,
                  1,
                ],
              },
            },
            "required": [
              "Status",
            ],
            "type": "object",
          },
        },
      ],
    },
    {
      "dtoSchema": {
        "description": "Describes an action to lock a token.",
        "properties": {
          "lockAuthority": {
            "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
            "type": "string",
          },
          "owner": {
            "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "The quantity of token units to be locked. Number provided as a string.",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be locked. In case of fungible tokens, tokenInstance.instance field should be set to 0. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used on lock (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "LockToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to lock multiple tokens.",
        "properties": {
          "expires": {
            "description": "Expiration timestamp. The TokenHold will expire at this time. This name will be applied to all token holds created by this Lock.",
            "minimum": 0,
            "type": "number",
          },
          "lockAuthority": {
            "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
            "type": "string",
          },
          "name": {
            "description": "Name for the token holds (optional). This name will be applied to all token holds created by this Lock.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstances": {
            "description": "Array of token instances of token to be locked. In case of fungible tokens, tokenInstance.instance field should be set to 0.",
            "items": {
              "properties": {
                "owner": {
                  "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "tokenInstanceKey": {
                  "description": "Object representing the chain identifier of token instance.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
              },
              "required": [
                "tokenInstanceKey",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used on lock (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "tokenInstances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "LockTokens",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to mint a token. For NFTs you can mint up to 1000 tokens.",
        "properties": {
          "allowanceKey": {
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of Fungible/NonFungible Token will be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "MintToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to grant allowance to self and mint token to owner in single transaction. This action will fail is the calling user lacks the authority to grant MINT allowances.",
        "properties": {
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of Fungible/NonFungible Token will be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "tokenInstance": {
            "description": "Instance of token to be minted Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "MintTokenWithAllowance",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Refresh the uses or expiration date of an existing allowance. If quantity needs updating, grant a new allowance instead.",
        "properties": {
          "allowances": {
            "items": {
              "description": "Refresh the uses or expiration date of an existing allowance. If quantity needs updating, grant a new allowance instead.",
              "properties": {
                "allowanceKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "expires": {
                  "minimum": 0,
                  "type": "number",
                },
                "prefix": {
                  "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerAddress": {
                  "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO.",
                  "minLength": 1,
                  "type": "string",
                },
                "signing": {
                  "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                  "enum": [
                    "ETH",
                    "TON",
                  ],
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
                "uses": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
              },
              "required": [
                "allowanceKey",
                "uses",
                "expires",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "allowances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RefreshAllowances",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "allowanceType": {
                  "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
                  "enum": [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                  ],
                  "type": "number",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "expires": {
                  "minimum": 0,
                  "type": "number",
                },
                "grantedBy": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "grantedTo": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantitySpent": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uses": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "usesSpent": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
              },
              "required": [
                "grantedTo",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "allowanceType",
                "grantedBy",
                "created",
                "uses",
                "expires",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to release a token that is in use.",
        "properties": {
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be released. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstance",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "ReleaseToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Experimental: Describes an action to mint a token. High-throughput implementation. DTO properties backwards-compatible with prior MintTokenDto,",
        "properties": {
          "allowanceKey": {
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of fungible token of how many NFTs are going to be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RequestMint",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
            "properties": {
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "requests": {
                "$ref": "#/definitions/Array",
                "items": {
                  "description": "Minimal property set represnting a mint request.",
                  "properties": {
                    "additionalKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "allowanceKey": {
                      "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "id": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "owner": {
                      "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                      "type": "string",
                    },
                    "timeKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "totalKnownMintsCount": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "timeKey",
                    "totalKnownMintsCount",
                    "id",
                  ],
                  "type": "object",
                },
                "maxItems": 1000,
                "minItems": 1,
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "requests",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
        "properties": {
          "from": {
            "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "The quantity of token units to be transferred. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "to": {
            "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be transferred. In case of fungible tokens, tokenInstance.instance field should be set to 0. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used on transferToken (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "to",
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "TransferToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to unlock a token.",
        "properties": {
          "lockedHoldName": {
            "description": "Optional. name property of the lockedHold defined on the balance. undefined by default. Usable by Token Authorities only.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "Optional. Owner of the token. Calling User by default. Usable by Token Authorities only.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "Optional quantity for unlocking fungible tokens. Not for use with NFT token instances. Number provided as a string.",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be unlocked. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstance",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UnlockToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to unlock multiple tokens.",
        "properties": {
          "name": {
            "description": "Name for the token holds (optional). Only token holds with this name will be Unlocked if provided.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstances": {
            "description": "Array of token instances of token to be locked. In case of fungible tokens, tokenInstance.instance field should be set to 0.",
            "items": {
              "properties": {
                "owner": {
                  "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "tokenInstanceKey": {
                  "description": "Object representing the chain identifier of token instance.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "prefix": {
                      "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerAddress": {
                      "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signing": {
                      "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                      "enum": [
                        "ETH",
                        "TON",
                      ],
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
              },
              "required": [
                "tokenInstanceKey",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UnlockTokens",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "properties": {
          "authorities": {
            "description": "List of chain user identifiers who should become token authorities. Only token authorities can give mint allowances. By default the calling user becomes a single token authority. ",
            "items": {
              "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
          "contractAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "description": {
            "maxLength": 1000,
            "minLength": 1,
            "type": "string",
          },
          "image": {
            "format": "url",
            "type": "string",
          },
          "metadataAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "name": {
            "maxLength": 200,
            "type": "string",
          },
          "overwriteAuthorities": {
            "description": "Overwrite existing authorities completely with new values. Default: false. The default behavior will augment the existing authorities with new values. Set this to true and provide a full list to remove one or more existing authorities.",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "rarity": {
            "description": "How rare is the NFT",
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "symbol": {
            "maxLength": 20,
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "tokenClass": {
            "description": "The unique identifier of the existing token which will be updated. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UpdateTokenClass",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Object representing the chain identifier of token class.",
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
    {
      "dtoSchema": {
        "description": "Describes an action to use a token.",
        "properties": {
          "inUseBy": {
            "description": "The user who is going to use token.",
            "type": "string",
          },
          "owner": {
            "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
            "type": "string",
          },
          "prefix": {
            "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "The quantity of token units to be used. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
            "minLength": 1,
            "type": "string",
          },
          "signerAddress": {
            "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO.",
            "minLength": 1,
            "type": "string",
          },
          "signing": {
            "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
            "enum": [
              "ETH",
              "TON",
            ],
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be used. In case of fungible tokens, tokenInstance.instance field should be set to 0. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "prefix": {
                "description": "Prefix for Metamask transaction signatures. Necessary to format payloads correctly to recover publicKey from web3 signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. 
Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures.",
                "minLength": 1,
                "type": "string",
              },
              "signerAddress": {
                "description": "Address of the user who signed the DTO. Typically Ethereum or TON address.",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO.",
                "minLength": 1,
                "type": "string",
              },
              "signing": {
                "description": "Signing scheme used for the signature. "ETH" for Ethereum, and "TON" for The Open Network are supported. Default: "ETH".",
                "enum": [
                  "ETH",
                  "TON",
                ],
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "inUseBy",
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UseToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "description": "Allowed value is string following the format of 'client|<user-id>', or 'eth|<checksumed-eth-addr>', or valid system-level username.",
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
    },
  ],
}
`;
