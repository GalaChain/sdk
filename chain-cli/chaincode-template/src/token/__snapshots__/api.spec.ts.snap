// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GalaChainTokenContract API should match snapshot 1`] = `
{
  "contractName": "GalaChainToken",
  "contractVersion": "?.?.?",
  "methods": [
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to transferToken a token. For NFTs you can mint up to 1000 tokens.",
        "properties": {
          "mintDtos": {
            "description": "DTOs of tokens to mint.",
            "items": {
              "description": "Describes an action to mint a token. For NFTs you can mint up to 1000 tokens.",
              "properties": {
                "allowanceKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "owner": {
                  "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "How many units of Fungible/NonFungible Token will be minted. Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "tokenClass": {
                  "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                  ],
                  "type": "object",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "tokenClass",
                "quantity",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "mintDtos",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BatchMintToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Defines burns to be created.",
        "properties": {
          "owner": {
            "description": "Owner of the tokens to be burned. If not provided, the calling user is assumed to be the owner.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstances": {
            "description": "Array of token instances of token to be burned. In case of fungible tokens, tokenInstance.instance field should be set to 0 and quantity set to 1.",
            "items": {
              "properties": {
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "tokenInstanceKey": {
                  "description": "Object representing the chain identifier of token instance.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
              },
              "required": [
                "tokenInstanceKey",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "BurnTokens",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "burnedBy": {
                  "minLength": 1,
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "burnedBy",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "created",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Contains properties of token class to be created. Actual token units and NFT instances are created on mint.",
        "properties": {
          "authorities": {
            "description": "List of chain user identifiers who should become token authorities. Only token authorities can give mint allowances. By default the calling user becomes a single token authority. ",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
          "contractAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "decimals": {
            "description": "If missing, and for NFTs, it is set to 0.",
            "maximum": 32,
            "minimum": 0,
            "type": "number",
          },
          "description": {
            "maxLength": 1000,
            "minLength": 1,
            "type": "string",
          },
          "image": {
            "format": "url",
            "type": "string",
          },
          "isNonFungible": {
            "description": "Determines if the token is an NFT. Set to false if missing.",
            "type": "boolean",
          },
          "maxCapacity": {
            "description": "If missing, set to Infinity. Number provided as a string.",
            "type": "string",
          },
          "maxSupply": {
            "description": "If missing, set to infinity Infinity. Number provided as a string.",
            "type": "string",
          },
          "metadataAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "name": {
            "maxLength": 200,
            "type": "string",
          },
          "network": {
            "description": "A network of the token. An optional field, by default set to GC. Custom value is required when we want to use different network than GC to store tokens (but this is not supported yet).",
            "minLength": 1,
            "type": "string",
          },
          "rarity": {
            "description": "How rare is the NFT",
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "symbol": {
            "maxLength": 20,
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "tokenClass": {
            "description": "A unique identifier of this token. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "totalBurned": {
            "description": "How much units or how many NFTs ware already burned. By default set to 0. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "totalMintAllowance": {
            "description": "How much units or how many NFTs were allowed to be minted in the past. By default set to 0. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "totalSupply": {
            "description": "How much units or how many NFTs are already on the market. By default set to 0. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "name",
          "symbol",
          "description",
          "image",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "CreateTokenClass",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Object representing the chain identifier of token class.",
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Contains parameters for deleting allowances for a calling user.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "allowanceType": {
            "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
            ],
            "type": "number",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "grantedBy": {
            "description": "User who granted allowances.",
            "minLength": 1,
            "type": "string",
          },
          "grantedTo": {
            "description": "A user who can use an allowance.",
            "minLength": 1,
            "type": "string",
          },
          "instance": {
            "description": "Token instance. Optional, but required if allowanceType is provided",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "grantedTo",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "DeleteAllowances",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "number",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Contains parameters for fetching allowances with pagination.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "allowanceType": {
            "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
            ],
            "type": "number",
          },
          "bookmark": {
            "description": "Page bookmark. If it is undefined, then the first page is returned.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "grantedBy": {
            "description": "User who granted allowances.",
            "minLength": 1,
            "type": "string",
          },
          "grantedTo": {
            "description": "A user who can use an allowance.",
            "minLength": 1,
            "type": "string",
          },
          "instance": {
            "description": "Token instance. Optional, but required if allowanceType is provided",
            "minLength": 1,
            "type": "string",
          },
          "limit": {
            "description": "Page size limit. Defaults to 1000, max possible value 10000. Note you will likely get less results than the limit, because the limit is applied before additional filtering.",
            "maximum": 10000,
            "minimum": 1,
            "type": "number",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "grantedTo",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchAllowances",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "nextPageBookmark": {
                "description": "Next page bookmark.",
                "minLength": 1,
                "type": "string",
              },
              "results": {
                "description": "List of allowances.",
                "items": {
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "allowanceType": {
                      "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
                      "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                      ],
                      "type": "number",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "grantedBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "grantedTo": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "quantitySpent": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uses": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "usesSpent": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "grantedTo",
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                    "allowanceType",
                    "grantedBy",
                    "created",
                    "uses",
                    "usesSpent",
                    "expires",
                    "quantity",
                    "quantitySpent",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "results",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Contains parameters for fetching balances. Each parameter is optional.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey.",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "Person who owns the balance. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchBalances",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Contains parameters for fetching burns.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "burnedBy": {
            "description": "The user who burned the token.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "created": {
            "description": "Created time. Optional.",
            "exclusiveMinimum": 0,
            "type": "number",
          },
          "instance": {
            "description": "Token instance. Optional, but required if allowanceType is provided.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "burnedBy",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchBurns",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "burnedBy": {
                  "minLength": 1,
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "burnedBy",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "created",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Fetch MintRequest or MintAllowanceRequest objects off chain.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection.",
            "minLength": 1,
            "type": "string",
          },
          "endTimestamp": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "startTimestamp": {
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "collection",
          "category",
          "type",
          "additionalKey",
          "startTimestamp",
          "endTimestamp",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchMintRequests",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Minimal property set represnting a mint request.",
              "properties": {
                "additionalKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "allowanceKey": {
                  "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                  "minLength": 1,
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "id": {
                  "minLength": 1,
                  "type": "string",
                },
                "owner": {
                  "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                  "minLength": 1,
                  "type": "string",
                },
                "timeKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "totalKnownMintsCount": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "timeKey",
                "totalKnownMintsCount",
                "id",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Contains list of objects representing token classes to fetch.",
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenClasses": {
            "items": {
              "description": "Object representing the chain identifier of token class.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClasses",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchTokenClasses",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "authorities": {
                  "items": {
                    "type": "string",
                  },
                  "type": "array",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "contractAddress": {
                  "maxLength": 500,
                  "type": "string",
                },
                "decimals": {
                  "maximum": 32,
                  "minimum": 0,
                  "type": "number",
                },
                "description": {
                  "maxLength": 1000,
                  "minLength": 1,
                  "type": "string",
                },
                "image": {
                  "maxLength": 500,
                  "minLength": 1,
                  "type": "string",
                },
                "isNonFungible": {
                  "type": "boolean",
                },
                "knownMintAllowanceSupply": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "knownMintSupply": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "maxCapacity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "maxSupply": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "metadataAddress": {
                  "maxLength": 500,
                  "type": "string",
                },
                "name": {
                  "minLength": 1,
                  "type": "string",
                },
                "network": {
                  "enum": [
                    "GC",
                  ],
                  "minLength": 1,
                  "type": "string",
                },
                "rarity": {
                  "pattern": "^[a-zA-Z]+$",
                  "type": "string",
                },
                "symbol": {
                  "minLength": 1,
                  "pattern": "^[a-zA-Z]+$",
                  "type": "string",
                },
                "totalBurned": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "totalMintAllowance": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "totalSupply": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "network",
                "decimals",
                "maxSupply",
                "isNonFungible",
                "maxCapacity",
                "authorities",
                "name",
                "symbol",
                "description",
                "image",
                "totalBurned",
                "totalMintAllowance",
                "totalSupply",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Fetch token classes currently available in world state. Supports filtering, pagination, and optionality of TokenClassKey properties.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, but required if instance is provided.",
            "minLength": 1,
            "type": "string",
          },
          "bookmark": {
            "description": "Page bookmark. If it is undefined, then the first page is returned.",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, but required if type is provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional, but required if category is provided.",
            "minLength": 1,
            "type": "string",
          },
          "limit": {
            "description": "Page size limit. Defaults to 1000, max possible value 10000. Note you will likely get less results than the limit, because the limit is applied before additional filtering.",
            "maximum": 10000,
            "minimum": 1,
            "type": "number",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, but required if additionalKey is provided.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchTokenClassesWithPagination",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "nextPageBookmark": {
                "description": "Next page bookmark.",
                "minLength": 1,
                "type": "string",
              },
              "results": {
                "description": "List of Token Classes.",
                "items": {
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "authorities": {
                      "items": {
                        "type": "string",
                      },
                      "type": "array",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "contractAddress": {
                      "maxLength": 500,
                      "type": "string",
                    },
                    "decimals": {
                      "maximum": 32,
                      "minimum": 0,
                      "type": "number",
                    },
                    "description": {
                      "maxLength": 1000,
                      "minLength": 1,
                      "type": "string",
                    },
                    "image": {
                      "maxLength": 500,
                      "minLength": 1,
                      "type": "string",
                    },
                    "isNonFungible": {
                      "type": "boolean",
                    },
                    "knownMintAllowanceSupply": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "knownMintSupply": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "maxCapacity": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "maxSupply": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "metadataAddress": {
                      "maxLength": 500,
                      "type": "string",
                    },
                    "name": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "network": {
                      "enum": [
                        "GC",
                      ],
                      "minLength": 1,
                      "type": "string",
                    },
                    "rarity": {
                      "pattern": "^[a-zA-Z]+$",
                      "type": "string",
                    },
                    "symbol": {
                      "minLength": 1,
                      "pattern": "^[a-zA-Z]+$",
                      "type": "string",
                    },
                    "totalBurned": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "totalMintAllowance": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "totalSupply": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "network",
                    "decimals",
                    "maxSupply",
                    "isNonFungible",
                    "maxCapacity",
                    "authorities",
                    "name",
                    "symbol",
                    "description",
                    "image",
                    "totalBurned",
                    "totalMintAllowance",
                    "totalSupply",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "results",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
        "properties": {
          "requests": {
            "$ref": "#/definitions/Array",
            "items": {
              "description": "Minimal property set represnting a mint request.",
              "properties": {
                "additionalKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "allowanceKey": {
                  "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                  "minLength": 1,
                  "type": "string",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "id": {
                  "minLength": 1,
                  "type": "string",
                },
                "owner": {
                  "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                  "minLength": 1,
                  "type": "string",
                },
                "timeKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "totalKnownMintsCount": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "timeKey",
                "totalKnownMintsCount",
                "id",
              ],
              "type": "object",
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "requests",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "FulfillMint",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Fetch one or more balances, verify all owned TokenInstances have at least one available allowance of the specified type. Any token instance key(s) with no available allowances will be returned in the response.",
        "properties": {
          "additionalKey": {
            "description": "Token additionalKey. Optional, and ignored if type is not provided.",
          },
          "allowanceType": {
            "description": "AllowanceType to check. Default: Use (0)",
            "minLength": 1,
            "type": "string",
          },
          "category": {
            "description": "Token category. Optional, and ignored if collection is not provided.",
            "minLength": 1,
            "type": "string",
          },
          "collection": {
            "description": "Token collection. Optional.",
            "minLength": 1,
            "type": "string",
          },
          "grantedTo": {
            "description": "Person/UserId to whom allowance(s) were granted. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "Person who owns the balance(s). If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "type": {
            "description": "Token type. Optional, and ignored if category is not provded.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FullAllowanceCheck",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Response Data Transfer Object for FullLockAllowance request.",
            "properties": {
              "all": {
                "description": "True if all resulting token(s) have active/un-expired allowances available.",
                "type": "boolean",
              },
              "missing": {
                "description": "TokenInstanceKey(s) of any tokens missing the requested AllowanceType.",
                "items": {
                  "description": "Object representing the chain identifier of token instance.",
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
                "minItems": 1,
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "all",
              "missing",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": undefined,
      "isWrite": false,
      "methodName": "GetChaincodeVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": undefined,
      "isWrite": false,
      "methodName": "GetContractAPI",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectByKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectHistory",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Defines allowances to be created.",
        "properties": {
          "allowanceType": {
            "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
            "enum": [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
            ],
            "minLength": 1,
            "type": "string",
          },
          "expires": {
            "description": "Unix timestamp of the date when the allowances should expire. 0 means that it won' expire. By default set to 0.",
          },
          "quantities": {
            "$ref": "#/definitions/Array",
            "description": "List of objects with user and token quantities. The user fields must be unique",
            "items": {
              "properties": {
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "user": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "user",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token which the allowance concerns. In case of fungible tokens, tokenInstance.instance field should be set to 0. A full or partial key of a TokenInstance, for querying or actioning one or more instances of a token.",
            "minLength": 1,
            "properties": {
              "additionalKey": {},
              "category": {},
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {},
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "uses": {
            "description": "How many times each allowance can be used. Number provided as a string.",
            "type": "string",
          },
        },
        "required": [
          "tokenInstance",
          "quantities",
          "allowanceType",
          "uses",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "GrantAllowance",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "allowanceType": {
                  "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
                  "enum": [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                  ],
                  "type": "number",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "expires": {
                  "minimum": 0,
                  "type": "number",
                },
                "grantedBy": {
                  "minLength": 1,
                  "type": "string",
                },
                "grantedTo": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantitySpent": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uses": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "usesSpent": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
              },
              "required": [
                "grantedTo",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "allowanceType",
                "grantedBy",
                "created",
                "uses",
                "usesSpent",
                "expires",
                "quantity",
                "quantitySpent",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Experimental: Describes an action to mint a token. High-throughput implementation. DTO properties backwards-compatible with prior MintTokenDto,",
        "properties": {
          "allowanceKey": {
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of fungible token of how many NFTs are going to be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "HighThroughputMint",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": [
        {
          "dtoSchema": {
            "description": "Experimental: Describes an action to mint a token. High-throughput implementation. DTO properties backwards-compatible with prior MintTokenDto,",
            "properties": {
              "allowanceKey": {
                "minLength": 1,
                "type": "string",
              },
              "owner": {
                "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "How many units of fungible token of how many NFTs are going to be minted. Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "tokenClass": {
                "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
                "minLength": 1,
                "properties": {
                  "additionalKey": {
                    "not": {
                      "type": "null",
                    },
                  },
                  "category": {
                    "minLength": 1,
                    "type": "string",
                  },
                  "collection": {
                    "minLength": 1,
                    "type": "string",
                  },
                  "signature": {
                    "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerPublicKey": {
                    "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "type": {
                    "minLength": 1,
                    "type": "string",
                  },
                  "uniqueKey": {
                    "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                    "minLength": 1,
                    "type": "string",
                  },
                },
                "required": [
                  "collection",
                  "category",
                  "type",
                  "additionalKey",
                ],
                "type": "object",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "tokenClass",
              "quantity",
            ],
            "type": "object",
          },
          "isWrite": true,
          "methodName": "RequestMint",
          "responseSchema": {
            "properties": {
              "Data": {
                "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
                "properties": {
                  "requests": {
                    "$ref": "#/definitions/Array",
                    "items": {
                      "description": "Minimal property set represnting a mint request.",
                      "properties": {
                        "additionalKey": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "allowanceKey": {
                          "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                          "minLength": 1,
                          "type": "string",
                        },
                        "category": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "collection": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "id": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "owner": {
                          "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                          "minLength": 1,
                          "type": "string",
                        },
                        "timeKey": {
                          "minLength": 1,
                          "type": "string",
                        },
                        "totalKnownMintsCount": {
                          "description": "Number provided as a string.",
                          "type": "string",
                        },
                        "type": {
                          "minLength": 1,
                          "type": "string",
                        },
                      },
                      "required": [
                        "collection",
                        "category",
                        "type",
                        "additionalKey",
                        "timeKey",
                        "totalKnownMintsCount",
                        "id",
                      ],
                      "type": "object",
                    },
                    "maxItems": 1000,
                    "minItems": 1,
                    "type": "array",
                  },
                  "signature": {
                    "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                    "minLength": 1,
                    "type": "string",
                  },
                  "signerPublicKey": {
                    "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                    "minLength": 1,
                    "type": "string",
                  },
                  "uniqueKey": {
                    "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                    "minLength": 1,
                    "type": "string",
                  },
                },
                "required": [
                  "requests",
                ],
                "type": "object",
              },
              "Message": {
                "type": "string",
              },
              "Status": {
                "description": "Indicates Error (0) or Success (1)",
                "enum": [
                  0,
                  1,
                ],
              },
            },
            "required": [
              "Status",
            ],
            "type": "object",
          },
        },
        {
          "dtoSchema": {
            "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
            "properties": {
              "requests": {
                "$ref": "#/definitions/Array",
                "items": {
                  "description": "Minimal property set represnting a mint request.",
                  "properties": {
                    "additionalKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "allowanceKey": {
                      "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "id": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "owner": {
                      "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "timeKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "totalKnownMintsCount": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "timeKey",
                    "totalKnownMintsCount",
                    "id",
                  ],
                  "type": "object",
                },
                "maxItems": 1000,
                "minItems": 1,
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "requests",
            ],
            "type": "object",
          },
          "isWrite": true,
          "methodName": "FulfillMint",
          "responseSchema": {
            "properties": {
              "Data": {
                "items": {
                  "description": "Object representing the chain identifier of token instance.",
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "Message": {
                "type": "string",
              },
              "Status": {
                "description": "Indicates Error (0) or Success (1)",
                "enum": [
                  0,
                  1,
                ],
              },
            },
            "required": [
              "Status",
            ],
            "type": "object",
          },
        },
      ],
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to lock a token.",
        "properties": {
          "lockAuthority": {
            "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "The quantity of token units to be locked. Number provided as a string.",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be locked. In case of fungible tokens, tokenInstance.instance field should be set to 0. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used on lock (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "LockToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to lock multiple tokens.",
        "properties": {
          "expires": {
            "description": "Expiration timestamp. The TokenHold will expire at this time. This name will be applied to all token holds created by this Lock.",
            "minimum": 0,
            "type": "number",
          },
          "lockAuthority": {
            "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
            "minLength": 1,
            "type": "string",
          },
          "name": {
            "description": "Name for the token holds (optional). This name will be applied to all token holds created by this Lock.",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstances": {
            "description": "Array of token instances of token to be locked. In case of fungible tokens, tokenInstance.instance field should be set to 0.",
            "items": {
              "properties": {
                "owner": {
                  "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "tokenInstanceKey": {
                  "description": "Object representing the chain identifier of token instance.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
              },
              "required": [
                "tokenInstanceKey",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used on lock (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "tokenInstances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "LockTokens",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to mint a token. For NFTs you can mint up to 1000 tokens.",
        "properties": {
          "allowanceKey": {
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of Fungible/NonFungible Token will be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "MintToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to grant allowance to self and mint token to owner in single transaction. This action will fail is the calling user lacks the authority to grant MINT allowances.",
        "properties": {
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of Fungible/NonFungible Token will be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "tokenInstance": {
            "description": "Instance of token to be minted Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "MintTokenWithAllowance",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "description": "Object representing the chain identifier of token instance.",
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Refresh the uses or expiration date of an existing allowance. If quantity needs updating, grant a new allowance instead.",
        "properties": {
          "allowances": {
            "items": {
              "description": "Refresh the uses or expiration date of an existing allowance. If quantity needs updating, grant a new allowance instead.",
              "properties": {
                "allowanceKey": {
                  "minLength": 1,
                  "type": "string",
                },
                "expires": {
                  "minimum": 0,
                  "type": "number",
                },
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
                "uses": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
              },
              "required": [
                "allowanceKey",
                "uses",
                "expires",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "allowances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RefreshAllowances",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "allowanceType": {
                  "description": "0 - Use, 1 - Lock, 2 - Spend, 3 - Transfer, 4 - Mint, 5 - Swap, 6 - Burn",
                  "enum": [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                  ],
                  "type": "number",
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "created": {
                  "exclusiveMinimum": 0,
                  "type": "number",
                },
                "expires": {
                  "minimum": 0,
                  "type": "number",
                },
                "grantedBy": {
                  "minLength": 1,
                  "type": "string",
                },
                "grantedTo": {
                  "minLength": 1,
                  "type": "string",
                },
                "instance": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantitySpent": {
                  "description": "Number provided as a string.",
                  "minLength": 1,
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
                "uses": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "usesSpent": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
              },
              "required": [
                "grantedTo",
                "collection",
                "category",
                "type",
                "additionalKey",
                "instance",
                "allowanceType",
                "grantedBy",
                "created",
                "uses",
                "usesSpent",
                "expires",
                "quantity",
                "quantitySpent",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to release a token that is in use.",
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be released. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstance",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "ReleaseToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Experimental: Describes an action to mint a token. High-throughput implementation. DTO properties backwards-compatible with prior MintTokenDto,",
        "properties": {
          "allowanceKey": {
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "How many units of fungible token of how many NFTs are going to be minted. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenClass": {
            "description": "Token class of token to be minted. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "RequestMint",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
            "properties": {
              "requests": {
                "$ref": "#/definitions/Array",
                "items": {
                  "description": "Minimal property set represnting a mint request.",
                  "properties": {
                    "additionalKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "allowanceKey": {
                      "description": "(Optional). Specify the TokenAllowance on chain to use for this mint.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "id": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "owner": {
                      "description": "The owner of minted tokens. If the value is missing, chaincode caller is used.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "timeKey": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "totalKnownMintsCount": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "timeKey",
                    "totalKnownMintsCount",
                    "id",
                  ],
                  "type": "object",
                },
                "maxItems": 1000,
                "minItems": 1,
                "type": "array",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "requests",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Experimental: After submitting request to RequestMintAllowance, follow up with FulfillMintAllowance.",
        "properties": {
          "from": {
            "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "The quantity of token units to be transferred. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "to": {
            "minLength": 1,
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be transferred. In case of fungible tokens, tokenInstance.instance field should be set to 0. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used on transferToken (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "to",
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "TransferToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to unlock a token.",
        "properties": {
          "quantity": {
            "description": "Optional quantity for unlocking fungible tokens. Not for use with NFT token instances. Number provided as a string.",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be unlocked. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstance",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UnlockToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to unlock multiple tokens.",
        "properties": {
          "name": {
            "description": "Name for the token holds (optional). Only token holds with this name will be Unlocked if provided.",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstances": {
            "description": "Array of token instances of token to be locked. In case of fungible tokens, tokenInstance.instance field should be set to 0.",
            "items": {
              "properties": {
                "owner": {
                  "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "tokenInstanceKey": {
                  "description": "Object representing the chain identifier of token instance.",
                  "minLength": 1,
                  "properties": {
                    "additionalKey": {
                      "not": {
                        "type": "null",
                      },
                    },
                    "category": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "collection": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "instance": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signature": {
                      "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                      "minLength": 1,
                      "type": "string",
                    },
                    "signerPublicKey": {
                      "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "type": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "uniqueKey": {
                      "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                      "minLength": 1,
                      "type": "string",
                    },
                  },
                  "required": [
                    "collection",
                    "category",
                    "type",
                    "additionalKey",
                    "instance",
                  ],
                  "type": "object",
                },
              },
              "required": [
                "tokenInstanceKey",
                "quantity",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenInstances",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UnlockTokens",
      "responseSchema": {
        "properties": {
          "Data": {
            "items": {
              "properties": {
                "additionalKey": {
                  "not": {
                    "type": "null",
                  },
                },
                "category": {
                  "minLength": 1,
                  "type": "string",
                },
                "collection": {
                  "minLength": 1,
                  "type": "string",
                },
                "inUseHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "instanceIds": {},
                "lockedHolds": {
                  "items": {
                    "properties": {
                      "created": {
                        "exclusiveMinimum": 0,
                        "type": "number",
                      },
                      "createdBy": {
                        "minLength": 1,
                        "type": "string",
                      },
                      "expires": {
                        "minimum": 0,
                        "type": "number",
                      },
                      "instanceId": {
                        "description": "Number provided as a string.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "lockAuthority": {
                        "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                        "minLength": 1,
                        "type": "string",
                      },
                      "name": {
                        "type": "string",
                      },
                      "quantity": {
                        "description": "Number provided as a string.",
                        "type": "string",
                      },
                    },
                    "required": [
                      "createdBy",
                      "instanceId",
                      "quantity",
                      "created",
                      "expires",
                    ],
                    "type": "object",
                  },
                  "type": "array",
                },
                "owner": {
                  "minLength": 1,
                  "type": "string",
                },
                "quantity": {
                  "description": "Number provided as a string.",
                  "type": "string",
                },
                "type": {
                  "minLength": 1,
                  "type": "string",
                },
              },
              "required": [
                "owner",
                "collection",
                "category",
                "type",
                "additionalKey",
                "quantity",
              ],
              "type": "object",
            },
            "type": "array",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "authorities": {
            "description": "List of chain user identifiers who should become token authorities. Only token authorities can give mint allowances. By default the calling user becomes a single token authority. ",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
          "contractAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "description": {
            "maxLength": 1000,
            "minLength": 1,
            "type": "string",
          },
          "image": {
            "format": "url",
            "type": "string",
          },
          "metadataAddress": {
            "maxLength": 500,
            "type": "string",
          },
          "name": {
            "maxLength": 200,
            "type": "string",
          },
          "overwriteAuthorities": {
            "description": "Overwrite existing authorities completely with new values. Default: false. The default behavior will augment the existing authorities with new values. Set this to true and provide a full list to remove one or more existing authorities.",
          },
          "rarity": {
            "description": "How rare is the NFT",
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "symbol": {
            "maxLength": 20,
            "pattern": "^[a-zA-Z]+$",
            "type": "string",
          },
          "tokenClass": {
            "description": "The unique identifier of the existing token which will be updated. Object representing the chain identifier of token class.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "tokenClass",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UpdateTokenClass",
      "responseSchema": {
        "properties": {
          "Data": {
            "description": "Object representing the chain identifier of token class.",
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "description": "Describes an action to use a token.",
        "properties": {
          "inUseBy": {
            "description": "The user who is going to use token.",
            "minLength": 1,
            "type": "string",
          },
          "owner": {
            "description": "The current owner of tokens. If the value is missing, chaincode caller is used.",
            "minLength": 1,
            "type": "string",
          },
          "quantity": {
            "description": "The quantity of token units to be used. Number provided as a string.",
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "tokenInstance": {
            "description": "Token instance of token to be used. In case of fungible tokens, tokenInstance.instance field should be set to 0. Object representing the chain identifier of token instance.",
            "minLength": 1,
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "instance": {
                "description": "Number provided as a string.",
                "minLength": 1,
                "type": "string",
              },
              "signature": {
                "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                "minLength": 1,
                "type": "string",
              },
              "signerPublicKey": {
                "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                "minLength": 1,
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
              "uniqueKey": {
                "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "collection",
              "category",
              "type",
              "additionalKey",
              "instance",
            ],
            "type": "object",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "useAllowances": {
            "description": "Allowance ids to be used (optional).",
            "items": {
              "type": "string",
            },
            "minItems": 1,
            "type": "array",
          },
        },
        "required": [
          "inUseBy",
          "tokenInstance",
          "quantity",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "UseToken",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "additionalKey": {
                "not": {
                  "type": "null",
                },
              },
              "category": {
                "minLength": 1,
                "type": "string",
              },
              "collection": {
                "minLength": 1,
                "type": "string",
              },
              "inUseHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "instanceIds": {},
              "lockedHolds": {
                "items": {
                  "properties": {
                    "created": {
                      "exclusiveMinimum": 0,
                      "type": "number",
                    },
                    "createdBy": {
                      "minLength": 1,
                      "type": "string",
                    },
                    "expires": {
                      "minimum": 0,
                      "type": "number",
                    },
                    "instanceId": {
                      "description": "Number provided as a string.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "lockAuthority": {
                      "description": "User who will be able to unlock token. If the value is missing, then token owner and lock creator can unlock in all cases token authority can unlock token.",
                      "minLength": 1,
                      "type": "string",
                    },
                    "name": {
                      "type": "string",
                    },
                    "quantity": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                  },
                  "required": [
                    "createdBy",
                    "instanceId",
                    "quantity",
                    "created",
                    "expires",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
              "owner": {
                "minLength": 1,
                "type": "string",
              },
              "quantity": {
                "description": "Number provided as a string.",
                "type": "string",
              },
              "type": {
                "minLength": 1,
                "type": "string",
              },
            },
            "required": [
              "owner",
              "collection",
              "category",
              "type",
              "additionalKey",
              "quantity",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
  ],
}
`;
