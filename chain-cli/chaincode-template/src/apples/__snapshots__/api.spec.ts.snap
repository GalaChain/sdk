// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AppleContract API should match snapshot 1`] = `
{
  "contractName": "AppleContract",
  "contractVersion": "?.?.?",
  "methods": [
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "bookmark": {
            "type": "string",
          },
          "index": {},
          "limit": {},
          "plantedBy": {
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "variety": {
            "enum": [
              "HONEYCRISP",
              "GALA",
              "GOLDEN_DELICIOUS",
              "MCINTOSH",
            ],
            "type": "string",
          },
        },
        "type": "object",
      },
      "isWrite": false,
      "methodName": "FetchTrees",
      "responseSchema": {
        "properties": {
          "Data": {
            "properties": {
              "bookmark": {
                "type": "string",
              },
              "trees": {
                "items": {
                  "properties": {
                    "applesPicked": {
                      "description": "Number provided as a string.",
                      "type": "string",
                    },
                    "plantedBy": {
                      "type": "string",
                    },
                    "variety": {
                      "enum": [
                        "GALA",
                        "GOLDEN_DELICIOUS",
                        "HONEYCRISP",
                        "MCINTOSH",
                      ],
                      "type": "string",
                    },
                  },
                  "required": [
                    "plantedBy",
                    "variety",
                    "applesPicked",
                  ],
                  "type": "object",
                },
                "type": "array",
              },
            },
            "required": [
              "trees",
              "bookmark",
            ],
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": undefined,
      "isWrite": false,
      "methodName": "GetChaincodeVersion",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "string",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": undefined,
      "isWrite": false,
      "methodName": "GetContractAPI",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectByKey",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "objectId": {
            "minLength": 1,
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "objectId",
        ],
        "type": "object",
      },
      "isWrite": false,
      "methodName": "GetObjectHistory",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "object",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "PlantedBy": {
            "type": "string",
          },
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "variety": {
            "enum": [
              "GALA",
              "GOLDEN_DELICIOUS",
              "HONEYCRISP",
              "MCINTOSH",
            ],
            "type": "string",
          },
        },
        "required": [
          "PlantedBy",
          "variety",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "PickApple",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
          "variety": {
            "enum": [
              "GALA",
              "GOLDEN_DELICIOUS",
              "HONEYCRISP",
              "MCINTOSH",
            ],
            "type": "string",
          },
        },
        "required": [
          "variety",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "PlantTree",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
    {
      "apiMethodName": undefined,
      "description": undefined,
      "dtoSchema": {
        "properties": {
          "signature": {
            "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
            "minLength": 1,
            "type": "string",
          },
          "signerPublicKey": {
            "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
            "minLength": 1,
            "type": "string",
          },
          "trees": {
            "items": {
              "properties": {
                "signature": {
                  "description": "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.
JSON payload to be signed is created from an object without 'signature' and 'trace\` properties, and it's keys should be sorted alphabetically and no end of line at the end. Sample jq command to produce valid data to sign: \`jq -cSj "." dto-file.json\`.Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.
The EC secp256k1 signature should be created for keccak256 hash of the data. The recommended format of the signature is a HEX encoded string, including r + s + v values. Signature in this format is supported by ethers.js library. Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b
This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. DER encoded signature cannot be used recover user's public key from the signature, and cannot be used with the new signature-based authorization flow for Gala Chain.
",
                  "minLength": 1,
                  "type": "string",
                },
                "signerPublicKey": {
                  "description": "Public key of the user who signed the DTO. Required for DER encoded signatures, since they miss recovery part.",
                  "minLength": 1,
                  "type": "string",
                },
                "uniqueKey": {
                  "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
                  "minLength": 1,
                  "type": "string",
                },
                "variety": {
                  "enum": [
                    "GALA",
                    "GOLDEN_DELICIOUS",
                    "HONEYCRISP",
                    "MCINTOSH",
                  ],
                  "type": "string",
                },
              },
              "required": [
                "variety",
              ],
              "type": "object",
            },
            "minItems": 1,
            "type": "array",
          },
          "uniqueKey": {
            "description": "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. The key is saved on chain and checked before execution. If a DTO with already saved key is used in transaction, the transaction will fail with UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. In case of the error, no changes are saved to chain state.
The key is generated by the caller and should be unique for each DTO. You can use \`nanoid\` library, UUID scheme, or any tool to generate unique string keys.",
            "minLength": 1,
            "type": "string",
          },
        },
        "required": [
          "trees",
        ],
        "type": "object",
      },
      "isWrite": true,
      "methodName": "PlantTrees",
      "responseSchema": {
        "properties": {
          "Data": {
            "type": "null",
          },
          "Message": {
            "type": "string",
          },
          "Status": {
            "description": "Indicates Error (0) or Success (1)",
            "enum": [
              0,
              1,
            ],
          },
        },
        "required": [
          "Status",
        ],
        "type": "object",
      },
      "sequence": undefined,
    },
  ],
}
`;
