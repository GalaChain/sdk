/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Type, instanceToInstance, plainToInstance } from "class-transformer";
import { IsNotEmpty, IsOptional, ValidationError, validate } from "class-validator";
import { JSONSchema } from "class-validator-jsonschema";
import crypto from "crypto";

import {
  SigningScheme,
  ValidationFailedError,
  deserialize,
  getValidationErrorMessages,
  serialize,
  signatures
} from "../utils";
import { IsUserAlias, StringEnumProperty } from "../validators";
import { GalaChainResponse } from "./contract";

type Base<T, BaseT> = T extends BaseT ? T : never;

// `any` is specified on purpose to avoid some compilation errors when `unknown` is provided here
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type Inferred<T, BaseT = any> = T extends (infer U)[] ? Base<U, BaseT> : Base<T, BaseT>;

export interface ClassConstructor<T> {
  new (...args: unknown[]): T;
}

class DtoValidationFailedError extends ValidationFailedError {
  constructor(errors: ValidationError[]) {
    const messages = getValidationErrorMessages(errors);
    const messagesString = messages.map((s, i) => `(${i + 1}) ${s}`).join(", ");
    super(`DTO validation failed: ${messagesString}`, messages);
  }
}

export const validateDTO = async <T extends ChainCallDTO>(dto: T): Promise<T> => {
  const validationErrors = await dto.validate();

  if (validationErrors.length) {
    throw new DtoValidationFailedError(validationErrors);
  } else {
    return dto;
  }
};

/**
 * Parses JSON string and creates a Promise with valid DTO. Throws exception in case of validation errors.
 */
export const parseValidDTO = async <T extends ChainCallDTO>(
  constructor: ClassConstructor<Inferred<T, ChainCallDTO>>,
  jsonStringOrObj: string | Record<string, unknown>
): Promise<T> => {
  const deserialized = ChainCallDTO.deserialize<T>(constructor, jsonStringOrObj);
  await validateDTO(deserialized);

  return deserialized;
};

// eslint-disable-next-line @typescript-eslint/ban-types
type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];

export type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;

export function randomUniqueKey(): string {
  return crypto.randomBytes(32).toString("base64");
}

/**
 * Creates valid DTO object from provided plain object.
 * Throws exception in case of validation errors.
 */
export function createValidDTO<T extends ChainCallDTO>(
  constructor: ClassConstructor<T>,
  plain: NonFunctionProperties<T>
): Promise<T> & { signed(privateKey: string): Promise<T> } {
  const instance = plainToInstance(constructor, plain) as T;
  const response = validateDTO(instance);

  // @ts-expect-error adding new method in runtime
  response.signed = (k: string) => response.then((r) => r.signed(k));

  return response as Promise<T> & { signed(privateKey: string): Promise<T> };
}

/**
 * Creates valid submit DTO object from provided plain object.
 * Throws exception in case of validation errors.
 * If the uniqueKey is not provided, it generates a random one: 32 random bytes in base64.
 */
export function createValidSubmitDTO<T extends SubmitCallDTO>(
  constructor: ClassConstructor<T>,
  plain: Omit<NonFunctionProperties<T>, "uniqueKey"> & { uniqueKey?: string }
): Promise<T> & { signed(privateKey: string): Promise<T> } {
  return createValidDTO<T>(constructor, {
    ...plain,
    uniqueKey: plain?.uniqueKey ?? randomUniqueKey()
  } as unknown as NonFunctionProperties<T>);
}

export interface TraceContext {
  spanId: string;
  traceId: string;
}

export class ChainCallDTO {
  public trace?: TraceContext;
  public static readonly ENCODING = "base64";

  @JSONSchema({
    description:
      "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. " +
      "The key is saved on chain and checked before execution. " +
      "If a DTO with already saved key is used in transaction, the transaction will fail with " +
      "UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. " +
      "In case of the error, no changes are saved to chain state.\n" +
      "The key is generated by the caller and should be unique for each DTO. " +
      "You can use `nanoid` library, UUID scheme, or any tool to generate unique string keys."
  })
  @IsNotEmpty()
  @IsOptional()
  public uniqueKey?: string;

  @JSONSchema({
    description:
      "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. " +
      "The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. \n" +
      "Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures."
  })
  @IsOptional()
  @IsNotEmpty()
  public signature?: string;

  @JSONSchema({
    description:
      "Prefix for Metamask transaction signatures. " +
      "Necessary to format payloads correctly to recover publicKey from web3 signatures."
  })
  @IsOptional()
  @IsNotEmpty()
  public prefix?: string;

  @JSONSchema({
    description: "Address of the user who signed the DTO. Typically Ethereum or TON address."
  })
  @IsOptional()
  @IsNotEmpty()
  public signerAddress?: string;

  @JSONSchema({
    description: "Public key of the user who signed the DTO."
  })
  @IsOptional()
  @IsNotEmpty()
  public signerPublicKey?: string;

  @JSONSchema({
    description:
      `Signing scheme used for the signature. ` +
      `"${SigningScheme.ETH}" for Ethereum, and "${SigningScheme.TON}" for The Open Network are supported. ` +
      `Default: "${SigningScheme.ETH}".`
  })
  @IsOptional()
  @StringEnumProperty(SigningScheme)
  public signing?: SigningScheme;

  validate(): Promise<ValidationError[]> {
    return validate(this);
  }

  async validateOrReject(): Promise<void> {
    const validationErrors = await this.validate();

    if (validationErrors.length) {
      throw new DtoValidationFailedError(validationErrors);
    }
  }

  serialize(): string {
    return serialize(this);
  }

  public static deserialize<T>(
    constructor: ClassConstructor<Inferred<T, ChainCallDTO>>,
    object: string | Record<string, unknown> | Record<string, unknown>[]
  ): T {
    return deserialize<T, ChainCallDTO>(constructor, object);
  }

  public sign(privateKey: string, useDer = false): void {
    if (this.signing === SigningScheme.TON) {
      const keyBuffer = Buffer.from(privateKey, "base64");
      this.signature = signatures.ton.getSignature(this, keyBuffer, this.prefix).toString("base64");
    } else {
      const keyBuffer = signatures.normalizePrivateKey(privateKey);
      this.signature = useDer
        ? signatures.getDERSignature(this, keyBuffer)
        : signatures.getSignature(this, keyBuffer);
    }
  }

  /**
   * Creates a signed copy of current object.
   */
  // note: previously it was typed as "typeof this", but it's failed randomly on compilation
  public signed(privateKey: string, useDer = false) {
    const copied = instanceToInstance(this);
    copied.sign(privateKey, useDer);
    return copied;
  }

  public isSignatureValid(publicKey: string): boolean {
    if (this.signing === SigningScheme.TON) {
      const signatureBuff = Buffer.from(this.signature ?? "", "base64");
      const publicKeyBuff = Buffer.from(publicKey, "base64");
      return signatures.ton.isValidSignature(signatureBuff, this, publicKeyBuff, this.prefix);
    } else {
      return signatures.isValid(this.signature ?? "", this, publicKey);
    }
  }
}

// It just makes uniqueKey required
export class SubmitCallDTO extends ChainCallDTO {
  @IsNotEmpty()
  public uniqueKey: string;
}

export class GetObjectDto extends ChainCallDTO {
  @IsNotEmpty()
  public readonly objectId: string;
}

export class GetObjectHistoryDto extends ChainCallDTO {
  @IsNotEmpty()
  public readonly objectId: string;
}

export class DryRunDto extends ChainCallDTO {
  @IsNotEmpty()
  public readonly method: string;

  @IsNotEmpty()
  public readonly callerPublicKey: string;

  @IsNotEmpty()
  @IsOptional()
  @Type(() => ChainCallDTO)
  dto?: ChainCallDTO;
}

export class DryRunResultDto extends ChainCallDTO {
  public response: GalaChainResponse<unknown>;
  public writes: Record<string, string>;
  public reads: Record<string, string>;
  public deletes: Record<string, true>;
}

export type RegisterUserParams = ConstructorArgs<RegisterUserDto>;

@JSONSchema({
  description: `Dto for secure method to save public keys for legacy users. Method is called and signed by Curators`
})
export class RegisterUserDto extends SubmitCallDTO {
  @JSONSchema({
    description: `Id of user to save public key for.`
  })
  @IsUserAlias()
  user: string;

  @JSONSchema({ description: "Public secp256k1 key (compact or non-compact, hex or base64)." })
  @IsNotEmpty()
  publicKey: string;
}

export type RegisterEthUserParams = ConstructorArgs<RegisterEthUserDto>;

@JSONSchema({
  description: `Dto for secure method to save public keys for Eth users. Method is called and signed by Curators`
})
export class RegisterEthUserDto extends SubmitCallDTO {
  @JSONSchema({ description: "Public secp256k1 key (compact or non-compact, hex or base64)." })
  @IsNotEmpty()
  publicKey: string;
}

export type RegisterTonUserParams = ConstructorArgs<RegisterTonUserDto>;

@JSONSchema({
  description: `Dto for secure method to save public keys for TON users. Method is called and signed by Curators`
})
export class RegisterTonUserDto extends SubmitCallDTO {
  @JSONSchema({ description: "TON user public key (Ed25519 in base64)." })
  @IsNotEmpty()
  publicKey: string;
}

export type UpdatePublicKeyParams = ConstructorArgs<UpdatePublicKeyDto>;

export class UpdatePublicKeyDto extends SubmitCallDTO {
  @JSONSchema({
    description:
      "For users with ETH signing scheme it is public secp256k1 key (compact or non-compact, hex or base64). " +
      "For users with TON signing scheme it is public Ed25519 key (base64)."
  })
  @IsNotEmpty()
  publicKey: string;
}

export type UpdateUserRolesParams = ConstructorArgs<UpdateUserRolesDto>;

export class UpdateUserRolesDto extends SubmitCallDTO {
  @IsUserAlias()
  user: string;

  @JSONSchema({ description: "New set of roles for the user that will replace the old ones." })
  @IsNotEmpty()
  roles: string[];
}

export type GetPublicKeyParams = ConstructorArgs<GetPublicKeyDto>;

export class GetPublicKeyDto extends ChainCallDTO {
  @JSONSchema({
    description: `Id of a public key holder. Optional field, by default caller's public key is returned.`
  })
  @IsOptional()
  @IsUserAlias()
  user?: string;
}

export type GetMyProfileParams = ConstructorArgs<GetMyProfileDto>;
export class GetMyProfileDto extends ChainCallDTO {
  // make signature required
  @IsNotEmpty()
  signature: string;
}
